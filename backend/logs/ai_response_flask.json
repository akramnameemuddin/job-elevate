{
  "questions": [
    {
      "question_text": "What type of Python web framework is Flask generally considered",
      "options": ["Microframework", "Full-stack framework", "Asynchronous framework", "ORM framework"],
      "correct_answer": "Microframework",
      "difficulty": "easy",
      "explanation": "Flask is known as a microframework because it provides core functionalities without many built-in features."
    },
    {
      "question_text": "Which function is used to initialize a Flask application instance",
      "options": ["Flask(__name__)", "App(__name__)", "create_app(__name__)", "run_app(__name__)"],
      "correct_answer": "Flask(__name__)",
      "difficulty": "easy",
      "explanation": "The Flask class from the flask module is used to create an application instance."
    },
    {
      "question_text": "How do you define a route for a URL path in Flask",
      "options": ["@app.route('/path')", "app.add_route('/path')", "route('/path')", "app.url('/path')"],
      "correct_answer": "@app.route('/path')",
      "difficulty": "easy",
      "explanation": "The @app.route decorator is used to associate a URL path with a view function."
    },
    {
      "question_text": "What templating engine does Flask use by default",
      "options": ["Jinja2", "Django Templates", "Mako", "Chameleon"],
      "correct_answer": "Jinja2",
      "difficulty": "easy",
      "explanation": "Flask integrates seamlessly with Jinja2 for rendering HTML templates."
    },
    {
      "question_text": "Which function is used to render an HTML template in Flask",
      "options": ["render_template()", "display_template()", "show_template()", "load_template()"],
      "correct_answer": "render_template()",
      "difficulty": "easy",
      "explanation": "The render_template function is imported from flask and used to render Jinja2 templates."
    },
    {
      "question_text": "What is the default port number for the Flask development server",
      "options": ["5000", "8000", "3000", "80"],
      "correct_answer": "5000",
      "difficulty": "easy",
      "explanation": "By default, Flask applications run on port 5000 during development."
    },
    {
      "question_text": "How can you access data submitted via an HTML form using POST method in Flask",
      "options": ["request.form", "request.args", "request.json", "request.data"],
      "correct_answer": "request.form",
      "difficulty": "easy",
      "explanation": "The request.form attribute contains key-value pairs of form data submitted via POST."
    },
    {
      "question_text": "What is the purpose of the __name__ argument when creating a Flask application instance",
      "options": ["It helps Flask locate resources like templates and static files", "It sets the application name for logging", "It defines the main module of the application", "It specifies the database connection string"],
      "correct_answer": "It helps Flask locate resources like templates and static files",
      "difficulty": "easy",
      "explanation": "Flask uses the __name__ argument to determine the root path of the application, which is crucial for finding templates and static files."
    },
    {
      "question_text": "How do you pass a variable named 'user' with value 'Alice' from a Flask route to a Jinja2 template",
      "options": ["render_template('template.html', user='Alice')", "render_template('template.html', {'user': 'Alice'})", "template.html(user='Alice')", "render_template('template.html').user = 'Alice'"],
      "correct_answer": "render_template('template.html', user='Alice')",
      "difficulty": "medium",
      "explanation": "Variables are passed to Jinja2 templates as keyword arguments to the render_template function."
    },
    {
      "question_text": "Which Flask function is used to generate a URL for a given endpoint function",
      "options": ["url_for()", "redirect()", "send_file()", "make_response()"],
      "correct_answer": "url_for()",
      "difficulty": "medium",
      "explanation": "The url_for function is used for URL building, which helps in avoiding hardcoding URLs and makes applications more flexible."
    },
    {
      "question_text": "How do you handle URL parameters like an item ID in a Flask route, e.g., /item/123",
      "options": ["@app.route('/item/<int:item_id>')", "@app.route('/item/?item_id=int')", "@app.route('/item/{item_id}')", "@app.route('/item/item_id')"],
      "correct_answer": "@app.route('/item/<int:item_id>')",
      "difficulty": "medium",
      "explanation": "Flask uses angle brackets to define variable parts in the URL, and type converters like int: can be used for validation."
    },
    {
      "question_text": "What is the primary purpose of a Blueprint in Flask",
      "options": ["To organize a Flask application into smaller, reusable components", "To define database schemas", "To manage user authentication", "To handle asynchronous tasks"],
      "correct_answer": "To organize a Flask application into smaller, reusable components",
      "difficulty": "medium",
      "explanation": "Blueprints allow you to modularize your application by grouping related views, templates, and static files."
    },
    {
      "question_text": "How can you store user-specific data that persists across multiple requests in Flask",
      "options": ["Using the session object", "Using global variables", "Using request.args", "Using a database directly for every request"],
      "correct_answer": "Using the session object",
      "difficulty": "medium",
      "explanation": "Flask provides a session object to store data specific to a user's session, which is typically stored in a signed cookie."
    },
    {
      "question_text": "What is the correct way to redirect a user to another endpoint named 'home' in Flask",
      "options": ["redirect(url_for('home'))", "return 'redirect to home'", "redirect('/home')", "response.redirect('home')"],
      "correct_answer": "redirect(url_for('home'))",
      "difficulty": "medium",
      "explanation": "The redirect function combined with url_for is the standard and recommended way to perform redirects in Flask."
    },
    {
      "question_text": "Explain the difference between Flasks application context and request context",
      "options": ["Application context exists for the lifetime of the application, request context for a single request", "Application context handles HTTP requests, request context handles background tasks", "Application context is for database operations, request context is for user sessions", "They are interchangeable terms for the same concept"],
      "correct_answer": "Application context exists for the lifetime of the application, request context for a single request",
      "difficulty": "hard",
      "explanation": "The application context is pushed when the application starts and contains app-level data, while the request context is pushed for each incoming request and contains request-specific data."
    },
    {
      "question_text": "Which of the following is a recommended strategy for managing database connections in a large Flask application to avoid resource leaks",
      "options": ["Using an application factory pattern with Flask-SQLAlchemy and proper teardown", "Opening a new database connection for every single query", "Storing database connections in global variables", "Relying on the database to automatically close connections after a timeout"],
      "correct_answer": "Using an application factory pattern with Flask-SQLAlchemy and proper teardown",
      "difficulty": "hard",
      "explanation": "An application factory combined with an ORM like Flask-SQLAlchemy and proper teardown functions ensures connections are managed efficiently and closed when no longer needed."
    },
    {
      "question_text": "When deploying a Flask application to production, what is the primary reason to use a WSGI server like Gunicorn or uWSGI instead of Flasks built-in development server",
      "options": ["The built-in server is not designed for performance, security, or scalability", "WSGI servers provide a graphical user interface for monitoring", "WSGI servers automatically generate API documentation", "The built-in server requires a paid license for production use"],
      "correct_answer": "The built-in server is not designed for performance, security, or scalability",
      "difficulty": "hard",
      "explanation": "Flasks development server is single-threaded and not robust enough for production environments, lacking features like proper request handling, security, and concurrency."
    },
    {
      "question_text": "How would you typically implement user authentication and authorization in a Flask application, considering best practices",
      "options": ["Using an extension like Flask-Login for authentication and custom decorators for authorization", "Manually managing user credentials in global variables", "Storing plaintext passwords in the session object", "Relying solely on client-side JavaScript for user verification"],
      "correct_answer": "Using an extension like Flask-Login for authentication and custom decorators for authorization",
      "difficulty": "hard",
      "explanation": "Flask-Login simplifies user session management and authentication, while custom decorators can enforce authorization rules on specific routes."
    },
    {
      "question_text": "What is a common approach to handle background tasks (e.g., sending emails, processing images) in a Flask application without blocking the main web server",
      "options": ["Integrating with a task queue like Celery or RQ", "Performing tasks synchronously within the request-response cycle", "Using Python's built-in threading module directly for every task", "Storing tasks in the session object for later processing"],
      "correct_answer": "Integrating with a task queue like Celery or RQ",
      "difficulty": "hard",
      "explanation": "Task queues like Celery or RQ allow you to offload long-running or resource-intensive tasks to separate worker processes, preventing the web server from blocking and improving responsiveness."
    },
    {
      "question_text": "In a Flask application, what is the significance of the current_app proxy",
      "options": ["It provides access to the currently active application instance within the application context", "It is a proxy for the currently logged-in user", "It stores configuration settings for the current request", "It allows direct access to the underlying WSGI server"],
      "correct_answer": "It provides access to the currently active application instance within the application context",
      "difficulty": "hard",
      "explanation": "current_app is a proxy that points to the Flask application instance that is currently active within the application context, allowing access to app-specific configurations and resources without explicit passing."
    }
  ]
}