{
  "questions": [
    {
      "question_text": "How do you define a method named greet in Ruby",
      "options": ["def greet; end", "function greet() {}", "method greet:", "greet = func() {}"],
      "correct_answer": "def greet; end",
      "difficulty": "easy",
      "explanation": "In Ruby, methods are defined using the def keyword followed by the method name and end."
    },
    {
      "question_text": "Which of the following is a valid way to create an array in Ruby",
      "options": ["[1, 2, 3]", "{1, 2, 3}", "(1, 2, 3)", "array(1, 2, 3)"],
      "correct_answer": "[1, 2, 3]",
      "difficulty": "easy",
      "explanation": "Arrays in Ruby are created using square brackets."
    },
    {
      "question_text": "What is the output of puts Hello +   + World",
      "options": ["Hello World", "HelloWorld", "Hello World", "Error"],
      "correct_answer": "Hello World",
      "difficulty": "easy",
      "explanation": "The + operator concatenates strings in Ruby."
    },
    {
      "question_text": "How do you assign the value 10 to a variable named x",
      "options": ["x = 10", "x == 10", "let x = 10", "assign x to 10"],
      "correct_answer": "x = 10",
      "difficulty": "easy",
      "explanation": "Variable assignment in Ruby uses the single equals sign."
    },
    {
      "question_text": "What is the primary purpose of the if statement in Ruby",
      "options": ["Conditional execution", "Looping through collections", "Defining a method", "Creating a class"],
      "correct_answer": "Conditional execution",
      "difficulty": "easy",
      "explanation": "The if statement allows code to be executed only if a certain condition is true."
    },
    {
      "question_text": "Which keyword is used to create a new class in Ruby",
      "options": ["class", "def", "module", "new"],
      "correct_answer": "class",
      "difficulty": "easy",
      "explanation": "The class keyword is used to define a new class."
    },
    {
      "question_text": "What is the result of 5 * 2 in Ruby",
      "options": ["10", "7", "52", "Error"],
      "correct_answer": "10",
      "difficulty": "easy",
      "explanation": "The * operator performs multiplication."
    },
    {
      "question_text": "How do you access the value associated with the key :name in a hash person = {name: Alice, age: 30}",
      "options": ["person[:name]", "person.name", "person[name]", "person->name"],
      "correct_answer": "person[:name]",
      "difficulty": "easy",
      "explanation": "Hash values are accessed using square brackets with the key, often a symbol."
    },
    {
      "question_text": "What is the main difference between a Proc and a Lambda in Ruby",
      "options": ["Lambdas enforce arity and return like methods, Procs do not", "Procs enforce arity and return like methods, Lambdas do not", "Procs can be passed as blocks, Lambdas cannot", "Lambdas are faster than Procs"],
      "correct_answer": "Lambdas enforce arity and return like methods, Procs do not",
      "difficulty": "medium",
      "explanation": "Lambdas check the number of arguments passed and return control to the caller like a method. Procs do not enforce arity and return from the current scope."
    },
    {
      "question_text": "In Ruby, what is the primary use case for a module that is included in a class",
      "options": ["Sharing behavior (mixins)", "Creating a new instance", "Defining a global variable", "Handling exceptions"],
      "correct_answer": "Sharing behavior (mixins)",
      "difficulty": "medium",
      "explanation": "Modules included in a class provide methods and constants to that class, acting as mixins to share common behavior."
    },
    {
      "question_text": "Which of the following code blocks correctly handles an exception in Ruby",
      "options": ["begin; raise Error; rescue => e; puts e.message; end", "try { throw Error; } catch (e) { console.log(e); }", "on error do; puts error; end", "handle Error do; puts error; end"],
      "correct_answer": "begin; raise Error; rescue => e; puts e.message; end",
      "difficulty": "medium",
      "explanation": "Ruby uses begin, rescue, and end for exception handling."
    },
    {
      "question_text": "What does the map method do when called on an array",
      "options": ["Transforms each element and returns a new array", "Iterates over each element without returning a new array", "Selects elements based on a condition", "Removes elements from the array"],
      "correct_answer": "Transforms each element and returns a new array",
      "difficulty": "medium",
      "explanation": "map (or collect) applies a block to each element and returns a new array containing the results."
    },
    {
      "question_text": "How does inheritance work in Ruby",
      "options": ["A class can inherit methods and attributes from a single parent class", "A class can inherit from multiple parent classes", "Inheritance is not supported in Ruby", "Only modules can inherit from other modules"],
      "correct_answer": "A class can inherit methods and attributes from a single parent class",
      "difficulty": "medium",
      "explanation": "Ruby supports single inheritance, where a class can inherit from one superclass."
    },
    {
      "question_text": "What is the main advantage of using Symbols over Strings as hash keys in Ruby",
      "options": ["Symbols are immutable and more memory efficient", "Symbols can contain any character", "Symbols are automatically converted to integers", "Symbols are only for internal use"],
      "correct_answer": "Symbols are immutable and more memory efficient",
      "difficulty": "medium",
      "explanation": "Symbols are unique identifiers and are stored only once in memory, making them efficient for use as hash keys or identifiers."
    },
    {
      "question_text": "Which Ruby method allows you to define a new instance method on a class dynamically at runtime",
      "options": ["define_method", "create_method", "add_method", "new_method"],
      "correct_answer": "define_method",
      "difficulty": "hard",
      "explanation": "define_method is a powerful metaprogramming tool that allows you to define methods dynamically within a class or module."
    },
    {
      "question_text": "In Ruby, what is the primary mechanism for memory management",
      "options": ["Garbage collection", "Manual memory allocation", "Reference counting", "Stack allocation only"],
      "correct_answer": "Garbage collection",
      "difficulty": "hard",
      "explanation": "Ruby uses an automatic garbage collector to manage memory, identifying and reclaiming objects that are no longer referenced."
    },
    {
      "question_text": "What is a Fiber in Ruby primarily used for",
      "options": ["Cooperative concurrency", "Parallel execution on multiple cores", "Asynchronous I/O operations", "Managing database connections"],
      "correct_answer": "Cooperative concurrency",
      "difficulty": "hard",
      "explanation": "Fibers allow for cooperative multitasking, where execution can be paused and resumed explicitly, enabling lightweight concurrency without threads."
    },
    {
      "question_text": "Which of the following is a common technique to optimize database access performance in Ruby on Rails applications, specifically to avoid N+1 queries",
      "options": ["Eager loading with includes or preload", "Using raw SQL queries", "Disabling database caching", "Fetching data one by one"],
      "correct_answer": "Eager loading with includes or preload",
      "difficulty": "hard",
      "explanation": "Eager loading fetches associated records in a single or a few queries, preventing the N+1 query problem where N additional queries are made for each parent record."
    },
    {
      "question_text": "When a module is prepended to a class, where do its methods appear in the method lookup chain relative to the classs own methods",
      "options": ["Before the classs own methods", "After the classs own methods", "They replace the classs own methods", "They are ignored"],
      "correct_answer": "Before the classs own methods",
      "difficulty": "hard",
      "explanation": "prepend inserts the module into the ancestor chain before the class itself, meaning its methods will be found and called first."
    },
    {
      "question_text": "What is the purpose of Rubys Refinement feature (introduced in Ruby 2.0)",
      "options": ["To locally modify the behavior of existing classes without affecting other parts of the application", "To permanently change core class behavior", "To define new global methods", "To create aliases for existing methods"],
      "correct_answer": "To locally modify the behavior of existing classes without affecting other parts of the application",
      "difficulty": "hard",
      "explanation": "Refinements allow for temporary, lexical-scoped modifications to existing classes, providing a way to extend classes without polluting the global namespace."
    }
  ]
}